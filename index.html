<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<title>Web Workshop</title>
	<link rel="icon" href="resources/rollerskate.png">
	<link rel="manifest" href="manifest.json">
	<script type="module">
		import {EditorView, keymap, placeholder, lineNumbers, Decoration} from "https://esm.sh/@codemirror/view@6"
		import {EditorState, Compartment, StateField, StateEffect} from "https://esm.sh/@codemirror/state@6"
		import {defaultKeymap, indentWithTab, undo, redo, undoDepth, redoDepth, history, historyKeymap} from "https://esm.sh/@codemirror/commands@6"
		import {closeBrackets, closeBracketsKeymap} from "https://esm.sh/@codemirror/autocomplete@6"
		import {html} from "https://esm.sh/@codemirror/lang-html@6"
		import {githubDark} from "https://esm.sh/@fsegurai/codemirror-theme-github-dark"
		import {indentUnit} from "https://esm.sh/@codemirror/language@6"
		import {search, searchKeymap, closeSearchPanel, openSearchPanel} from "https://esm.sh/@codemirror/search@6"
		
		window.CodeMirror = {EditorView, EditorState, Compartment, keymap, defaultKeymap, indentWithTab, html, githubDark, indentUnit, placeholder, undo, redo, undoDepth, redoDepth, history, historyKeymap, closeBrackets, closeBracketsKeymap, search, searchKeymap, closeSearchPanel, openSearchPanel, lineNumbers, Decoration, StateField, StateEffect};
	</script>
	<style>
		:root {
			--text-color: #f8f8f2;
			--editor-bg: #16181b;
		}

		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		body {
			font-family: monospace;
			background: var(--bg-color);
			color: var(--text-color);
			height: 100vh;
			display: flex;
			overflow: hidden;
		}

		.editor-pane {
			width: 50%;
			height: 100vh;
			position: relative;
		}

		.preview-pane {
			width: 50%;
			height: 100vh;
			position: relative;
		}

		.preview-pane.fullscreen {
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			z-index: 9999;
			background: white;
		}

		/* Hide editor when preview is fullscreen */
		.editor-pane.hidden {
			display: none;
		}

		#editor {
			width: 100%;
			height: 100%;
			font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
			font-size: 21px;
		}

		/* CodeMirror styling */
		.cm-editor {
			width: 100%;
			height: 100%;
			background: var(--editor-bg);
			color: var(--text-color);
		}

		.cm-placeholder {
			color: #666;
			opacity: 0.6;
		}

		.cm-content {
			padding: 15px;
			font-size: 21px;
			line-height: 1.6;
		}

		.cm-gutters {
			font-size: 21px;
			line-height: 1.6;
			user-select: none; 
		}

		.cm-lineNumbers .cm-gutterElement {
			line-height: 1.6;
			font-size: 21px;
		}

		.Í¼1 .cm-lineNumbers .cm-gutterElement {
			padding-right: 0;
			padding-left: 8px;
		}

		.cm-focused {
			outline: none;
		}

		/* Force tab size to 2 spaces - override theme defaults */
		.cm-editor .cm-content,
		.cm-editor .cm-line,
		.cm-editor {
			tab-size: 2 !important;
			-moz-tab-size: 2 !important;
		}

		/* Disable overscroll on all CodeMirror elements */
		.cm-editor, .cm-content, .cm-scroller, .cm-scrollElement {
			overscroll-behavior: none !important;
		}

		#preview {
			width: 100%;
			height: 100%;
			border: none;
			background: white;
			overflow: auto;
		}

		/* Vertical layout for narrow screens (height > width) */
		@media (max-aspect-ratio: 1/1) {
			body {
				flex-direction: column;
			}
			
			.editor-pane {
				width: 100%;
				height: 50vh;
				order: 2;
			}
			
			.preview-pane {
				width: 100%;
				height: 50vh;
				order: 1;
			}
		}

		/* Mobile keyboard state - portrait mode (height > width) */
		@media (pointer: coarse) and (max-aspect-ratio: 1/1), (pointer: none) and (max-aspect-ratio: 1/1) {
			body.mobile-keyboard-open .preview-pane {
				display: none;
			}
			
			body.mobile-keyboard-open .editor-pane {
				height: var(--visible-height, 100vh);
				order: 1;
				overflow: hidden;
			}
		}

		/* Mobile keyboard state - landscape mode (width > height) */
		@media (pointer: coarse) and (min-aspect-ratio: 1/1), (pointer: none) and (min-aspect-ratio: 1/1) {
			body.mobile-keyboard-open .preview-pane {
				display: none;
			}
			
			body.mobile-keyboard-open .editor-pane {
				width: 100%;
				height: var(--visible-height, 100vh);
				order: 1;
				overflow: hidden;
			}
		}

	</style>
</head>
<body>
	<div class="editor-pane">
		<div id="editor"></div>
	</div>
	
	<div class="preview-pane">
		<iframe id="preview"></iframe>
	</div>

	<script type="module">
		let updateTimer;
		let editorView;
		const preview = document.getElementById('preview');
		const storageKey = 'html-lab-content';
		let isFullscreen = false;
		let showLineNumbers = false;
		let lineNumbersCompartment;
		let showLineWrapping = false;
		let lineWrappingCompartment;

		function toggleFullscreen() {
			const previewPane = document.querySelector('.preview-pane');
			const editorPane = document.querySelector('.editor-pane');
			
			isFullscreen = !isFullscreen;
			
			if (isFullscreen) {
				previewPane.classList.add('fullscreen');
				editorPane.classList.add('hidden');
			} else {
				previewPane.classList.remove('fullscreen');
				editorPane.classList.remove('hidden');
			}
			
			// Update button title in iframe
			try {
				const toggleButton = preview.contentDocument.getElementById('fullscreenToggle');
				if (toggleButton) {
					toggleButton.title = isFullscreen ? 'Exit fullscreen' : 'Toggle fullscreen';
				}
			} catch (e) {
				// Ignore cross-origin errors
			}
		}


		// Listen for messages from iframe
		window.addEventListener('message', function(event) {
			if (event.data === 'toggleFullscreen') {
				toggleFullscreen();
			}
		});

		function extractTitleAndFavicon(htmlCode) {
			const parser = new DOMParser();
			const doc = parser.parseFromString(htmlCode, 'text/html');
			
			// Extract title
			const titleElement = doc.querySelector('title');
			const title = titleElement ? titleElement.textContent.trim() : null;
			
			// Extract favicon
			const faviconSelectors = [
				'link[rel="icon"]',
				'link[rel="shortcut icon"]', 
				'link[rel="apple-touch-icon"]',
				'link[rel="mask-icon"]'
			];
			
			let favicon = null;
			for (const selector of faviconSelectors) {
				const faviconElement = doc.querySelector(selector);
				if (faviconElement && faviconElement.href) {
					favicon = faviconElement.href;
					break;
				}
			}
			
			return { title, favicon };
		}

		function updateMainPageTitleAndFavicon(title, favicon) {
			// Update title
			if (title) {
				document.title = title;
			} else {
				document.title = 'Web Workshop';
			}
			
			// Update favicon
			let faviconLink = document.querySelector('link[rel="icon"]');
			if (!faviconLink) {
				faviconLink = document.createElement('link');
				faviconLink.rel = 'icon';
				document.head.appendChild(faviconLink);
			}
			
			if (favicon) {
				faviconLink.href = favicon;
			} else {
				faviconLink.href = 'resources/rollerskate.png';
			}
		}

		function updatePreview() {
			// Skip preview updates while mobile keyboard is open and editor is focused
			// This prevents keyboard layer resets on Android
			if (isMobileDevice() && isEditorFocused && document.body.classList.contains('mobile-keyboard-open')) {
				return;
			}
			
			const code = editorView.state.doc.toString();
			
			// Extract and update title and favicon from user's HTML
			const { title, favicon } = extractTitleAndFavicon(code);
			updateMainPageTitleAndFavicon(title, favicon);
			
			// Store scroll position before updating
			let scrollX = 0, scrollY = 0;
			try {
				if (preview.contentWindow?.scrollX !== undefined) {
					scrollX = preview.contentWindow.scrollX;
					scrollY = preview.contentWindow.scrollY;
				}
			} catch (e) {
				// Ignore cross-origin errors
			}
			
			// Use srcdoc to create a completely fresh document context
			preview.srcdoc = code.trim() || '<!DOCTYPE html><html><head></head><body></body></html>';
			
			// Add our functionality after the iframe loads
			const onLoad = () => {
				try {
					const doc = preview.contentDocument;
					if (!doc) return;
					
					// Add CSS for overscroll and button
					const style = doc.createElement('style');
					style.textContent = '* { overscroll-behavior: none !important; } .iframe-fullscreen-toggle { position: fixed; top: 5px; right: 5px; z-index: 10000; background: rgba(0, 0, 0, 0.2); color: white; border: none; border-radius: 4px; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: background-color 0.2s; box-shadow: 0 2px 2px rgba(0, 0, 0, 0.2); } .iframe-fullscreen-toggle img { filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.3)); opacity: 0.8; transition: opacity 0.2s; } @media (hover: hover) and (pointer: fine) { .iframe-fullscreen-toggle:hover { background: rgba(0, 0, 0, 0.35); } .iframe-fullscreen-toggle:hover img { opacity: 1; } }';
					doc.head.appendChild(style);
					
					// Create fullscreen button
					const existingButton = doc.getElementById('fullscreenToggle');
					if (existingButton) existingButton.remove();
					
					const button = doc.createElement('button');
					button.id = 'fullscreenToggle';
					button.className = 'iframe-fullscreen-toggle';
					button.title = 'Toggle fullscreen';
					
					const img = doc.createElement('img');
					img.src = 'resources/fullscreen.svg';
					img.width = 20;
					img.height = 20;
					img.alt = 'Fullscreen';
					button.appendChild(img);
					
					button.addEventListener('click', function() {
						parent.postMessage('toggleFullscreen', '*');
					});
					
					if (doc.body) {
						doc.body.appendChild(button);
					}
					
					// Restore scroll position
					setTimeout(() => {
						try {
							preview.contentWindow?.scrollTo(scrollX, scrollY);
						} catch (e) {
							// Ignore cross-origin errors
						}
					}, 10);
				} catch (e) {
					// Ignore cross-origin errors
				}
				
				preview.removeEventListener('load', onLoad);
			};
			preview.addEventListener('load', onLoad);
		}

		function saveToStorage() {
			try {
				localStorage.setItem(storageKey, editorView.state.doc.toString());
			} catch (e) {
				console.warn('Could not save to localStorage:', e);
			}
		}

		function loadFromStorage() {
			try {
				return localStorage.getItem(storageKey) || '';
			} catch (e) {
				console.warn('Could not load from localStorage:', e);
				return '';
			}
		}

		function loadEditorSettings() {
			try {
				showLineNumbers = localStorage.getItem('editor-line-numbers') === 'true';
				showLineWrapping = localStorage.getItem('editor-line-wrapping') === 'true';
			} catch (e) {
				console.warn('Could not load editor settings from localStorage:', e);
				showLineNumbers = false;
				showLineWrapping = false;
			}
		}

		function saveEditorSetting(key, value) {
			try {
				localStorage.setItem(key, value.toString());
			} catch (e) {
				console.warn('Could not save editor setting to localStorage:', e);
			}
		}

		function toggleLineNumbers() {
			const {lineNumbers} = window.CodeMirror;
			showLineNumbers = !showLineNumbers;
			saveEditorSetting('editor-line-numbers', showLineNumbers);
			
			editorView.dispatch({
				effects: lineNumbersCompartment.reconfigure(showLineNumbers ? lineNumbers() : [])
			});
		}

		function createLineWrappingPlugin() {
			const {EditorView, Decoration, StateField, StateEffect} = window.CodeMirror;
			
			// Line wrapping functionality
			const CharacterWidthEffect = StateEffect.define({});
			const extra_cycle_character_width = StateField.define({
				create() {
					return null;
				},
				update(value, tr) {
					for (let effect of tr.effects) {
						if (effect.is(CharacterWidthEffect)) return effect.value;
					}
					return value;
				}
			});

			const character_width_listener = EditorView.updateListener.of((viewupdate) => {
				const width = viewupdate.view.defaultCharacterWidth;
				const current_width = viewupdate.view.state.field(extra_cycle_character_width, false);

				if (current_width !== width) {
					viewupdate.view.dispatch({
						effects: [CharacterWidthEffect.of(width)]
					});
				}
			});

			const ARBITRARY_INDENT_LINE_WRAP_LIMIT = 48;
			const line_wrapping_decorations = StateField.define({
				create() {
					return Decoration.none;
				},
				update(deco, tr) {
					const tabSize = tr.state.tabSize;
					const charWidth = tr.state.field(extra_cycle_character_width, false);
					if (charWidth == null) return Decoration.none;

					if (!tr.docChanged && deco !== Decoration.none) return deco;

					const decorations = [];

					for (let i = 0; i < tr.state.doc.lines; i++) {
						const line = tr.state.doc.line(i + 1);
						if (line.length === 0) continue;

						let indented_chars = 0;
						for (const ch of line.text) {
							if (ch === '\t') {
								indented_chars = indented_chars + tabSize;
							} else if (ch === ' ') {
								indented_chars = indented_chars + 1;
							} else {
								break;
							}
						}

						// Only apply decoration to lines that have indentation
						if (indented_chars > 0) {
							const offset = Math.min(indented_chars, ARBITRARY_INDENT_LINE_WRAP_LIMIT) * charWidth;

							const rules = document.createElement('span').style;
							rules.setProperty('--idented', `${offset}px`);
							rules.setProperty('text-indent', 'calc(-1 * var(--idented) - 1px)');
							rules.setProperty('padding-left', 'calc(var(--idented) + 6px)');

							const linerwapper = Decoration.line({
								attributes: { style: rules.cssText }
							});

							decorations.push(linerwapper.range(line.from, line.from));
						}
					}
					return Decoration.set(decorations, true);
				},
				provide: (f) => EditorView.decorations.from(f)
			});

			return [extra_cycle_character_width, character_width_listener, line_wrapping_decorations];
		}

		function toggleLineWrapping() {
			const {EditorView} = window.CodeMirror;
			showLineWrapping = !showLineWrapping;
			saveEditorSetting('editor-line-wrapping', showLineWrapping);
			
			const wrapExtensions = showLineWrapping ? [EditorView.lineWrapping, ...createLineWrappingPlugin()] : [];
			editorView.dispatch({
				effects: lineWrappingCompartment.reconfigure(wrapExtensions)
			});
		}


		// File operations
		window.saveFile = function() {
			const blob = new Blob([editorView.state.doc.toString()], { type: 'text/html' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url;
			a.download = 'index.html';
			a.click();
			URL.revokeObjectURL(url);
		};

		window.loadFile = function() {
			const input = document.createElement('input');
			input.type = 'file';
			input.accept = '.html,.htm';
			input.onchange = function(event) {
				const file = event.target.files[0];
				if (!file) return;
				
				const reader = new FileReader();
				reader.onload = function(e) {
					editorView.dispatch({
						changes: { from: 0, to: editorView.state.doc.length, insert: e.target.result }
					});
					saveToStorage();
					updatePreview();
				};
				reader.readAsText(file);
			};
			input.click();
		};

		// Wait for CodeMirror to be available
		function initializeCodeMirror() {
			if (!window.CodeMirror) {
				setTimeout(initializeCodeMirror, 100);
				return;
			}

			const {EditorView, EditorState, Compartment, keymap, defaultKeymap, indentWithTab, html, githubDark, indentUnit, placeholder, undo, redo, undoDepth, redoDepth, history, historyKeymap, closeBrackets, closeBracketsKeymap, search, searchKeymap, closeSearchPanel, openSearchPanel, lineNumbers, Decoration, StateField, StateEffect} = window.CodeMirror;
			
			// Load saved content and editor settings
			const savedContent = loadFromStorage();
			loadEditorSettings();
			
			// Create compartments for dynamic extensions
			lineNumbersCompartment = new Compartment();
			lineWrappingCompartment = new Compartment();
			
			// Create CodeMirror editor
			editorView = new EditorView({
				state: EditorState.create({
					doc: savedContent,
					extensions: [
						history(),
						search(),
						closeBrackets(),
						keymap.of([
							{key: "Mod-z", run: undo},
							{key: "Mod-y", run: redo},
							{key: "Mod-Shift-z", run: redo},
							{key: "Mod-o", run: () => { window.loadFile(); return true; }},
							{key: "Mod-s", run: () => { window.saveFile(); return true; }},
							{key: "F1", run: () => { toggleLineNumbers(); return true; }},
							{key: "F2", run: () => { toggleLineWrapping(); return true; }},
							indentWithTab, 
							...searchKeymap.filter(binding => binding.key !== "Mod-f"),
							...defaultKeymap
						]),
						html(),
						githubDark,
						indentUnit.of("\t"),
						placeholder("Build something with HTML..."),
						EditorView.updateListener.of((update) => {
							if (update.docChanged) {
								clearTimeout(updateTimer);
								updateTimer = setTimeout(updatePreview, 600);
								saveToStorage();
							}
						}),
						// Disable text correction and autocomplete
						EditorView.contentAttributes.of({
							'autocomplete': 'off',
							'autocorrect': 'off',
							'autocapitalize': 'off',
							'spellcheck': 'false'
						}),
						lineNumbersCompartment.of(showLineNumbers ? lineNumbers() : []),
						lineWrappingCompartment.of([])
					]
				}),
				parent: document.getElementById('editor')
			});

			// Track editor focus for mobile keyboard behavior
			editorView.contentDOM.addEventListener('focus', function() {
				isEditorFocused = true;
				handleViewportChange(); // Check if keyboard is already open
			});
			
			editorView.contentDOM.addEventListener('blur', function() {
				isEditorFocused = false;
				handleViewportChange(); // Exit fullscreen mode if keyboard is open
			});
			
			// Initialize line wrapping if it was enabled
			if (showLineWrapping) {
				const wrapExtensions = [EditorView.lineWrapping, ...createLineWrappingPlugin()];
				editorView.dispatch({
					effects: lineWrappingCompartment.reconfigure(wrapExtensions)
				});
			}
			
			// Initial render
			updatePreview();
			
			// Focus the editor
			editorView.focus();
			
			// Global keydown handler for Cmd+F toggle
			document.addEventListener('keydown', function(e) {
				if ((e.metaKey || e.ctrlKey) && e.key === 'f') {
					e.preventDefault();
					closeSearchPanel(editorView) || openSearchPanel(editorView);
				}
			});
		}

		// Mobile keyboard detection
		let initialViewportHeight = window.visualViewport ? window.visualViewport.height : window.innerHeight;
		let keyboardOpenThreshold = 150; // pixels
		let isEditorFocused = false;
		let wasKeyboardOpen = false;
		
		function isMobileDevice() {
			return window.matchMedia("(pointer: coarse), (pointer: none)").matches;
		}
		
		function handleViewportChange() {
			if (!isMobileDevice()) return;
			
			const currentHeight = window.visualViewport ? window.visualViewport.height : window.innerHeight;
			
			// Detect potential orientation change: very large height difference when no keyboard activity
			// Use a higher threshold to avoid interfering with keyboard detection
			if (!wasKeyboardOpen && !isEditorFocused && Math.abs(initialViewportHeight - currentHeight) > 300) {
				initialViewportHeight = currentHeight;
			}
			
			const heightDifference = initialViewportHeight - currentHeight;
			const isKeyboardOpen = heightDifference > keyboardOpenThreshold;
			
			// Only activate fullscreen editor mode if the editor is focused
			if (isKeyboardOpen && isEditorFocused) {
				document.body.classList.add('mobile-keyboard-open');
				// Set CSS custom property for the visible height
				document.documentElement.style.setProperty('--visible-height', `${currentHeight}px`);
				// Match editor background color
				document.body.style.backgroundColor = 'var(--editor-bg)';
				wasKeyboardOpen = true;
			} else if (wasKeyboardOpen && !isKeyboardOpen) {
				// Only run this when transitioning from keyboard open to closed
				document.body.classList.remove('mobile-keyboard-open');
				// Reset to full viewport height
				document.documentElement.style.setProperty('--visible-height', '100vh');
				// Reset background color
				document.body.style.backgroundColor = '';
				// Blur the editor only if it was focused to prevent keyboard from reopening
				if (isEditorFocused) {
					editorView.contentDOM.blur();
				}
				// Update preview when keyboard closes to show any changes made while typing
				updatePreview();
				wasKeyboardOpen = false;
			}
		}
		
		// Listen for viewport changes
		if (window.visualViewport) {
			window.visualViewport.addEventListener('resize', handleViewportChange);
		} else {
			window.addEventListener('resize', handleViewportChange);
		}

		// Initialize when page loads
		initializeCodeMirror();

		// Register service worker
		if ('serviceWorker' in navigator) {
			window.addEventListener('load', () => {
				navigator.serviceWorker.register('./sw.js')
					.then(registration => {
						console.log('SW registered: ', registration);
					})
					.catch(registrationError => {
						console.log('SW registration failed: ', registrationError);
					});
			});
		}
	</script>
</body>
</html>